\chapter{Large sets and rapidly growing functions}\label{chap:alpha-large}


\section{Introduction}

In this chapter, we try to feel how long a standard battle can be.
To be precise, for any ordinal $\alpha<\epsilon0$ and any positive integer $k$,
we give a minoration of the number of steps of a standard battle which
starts with the hydra $\iota(\alpha)$ and the replication factor $k$.

We express this number in terms of the Hardy hierarchy of fast-growing 
functions~\cite{BW85, Wainer1970, KS81, Promel2013}.
 From the \coq{} user's point of view, such  functions are  very 
attractive:  they are defined as functions  in \gallina{}, and we can apply rhem \emph{in theory}, but they are so complex that you will never be able to look at the result of the computation.
 Thus, our knowledge on these functions must rely on \emph{proofs}. In our development, we use often the rewriting rules generated by \coq's \texttt{Equations} plug-in.


\section{Large  sequences}

\begin{definition}
Let $0<\alpha<\epsilon_0$ be any ordinal, and $s$ a sequence of strictly positive natural numbers. We say that $s$ is an  \emph{$\alpha$-large} 
sequence  if $s$ determines a path to the ordinal $0$.
We say that $s$ is \emph{minimally $\alpha$-large} (abbreviated in
\emph{$\alpha$-mlarge} if $s$ if $s$ is $\alpha$-large 
 and every strict prefix of $s$ leads to a non-zero ordinal. 

\index{Maths!Large sequences}
\index{Maths!Minimal large sequences}

\end{definition}


\begin{remark}
  Ketonen and Solovay~\cite{KS81} consider  large finite \emph{sets} of natural numbers,  but they are mainly used as sequences. Thus, we chosed to represent them explicitely as (sorted) lists. 
\end{remark}

\vspace{4pt}

\noindent
\emph{From Module~ \href{../src/html/hydras.Epsilon0.Large_Sets.html\#mlarge}{Epsilon0.Large\_Sets}}


\index{Predicates!mlarge @ mlarge (minimal large sequences)}
\begin{Coqsrc}
Definition mlarge alpha s := path_to zero s alpha.
\end{Coqsrc}


Let us consider two integers $k$ and $l$, such that $0<k<l$. In order to check whether the interval $[k,l]$ is minimally large for $\alpha$, it is enough to
follow from $\alpha$ the path associated with the interval $[k,l[$ and verify that the last ordinal we obtain is equal to $1$.
 
This verification can be done by a simple computation. First, we define a function for following a path, by successively computing canonical sequences.

\noindent
\emph{From Module~\href{../src/html/hydras.Epsilon0.Paths.html\#gnaw}{Epsilon0.Paths}}

\begin{Coqsrc}
Fixpoint gnaw (alpha : T1) (s: list nat) :=
  match s with
    | nil => alpha
    | (0::s') => gnaw  alpha s'
    | (S i :: s')  =>  gnaw (canonS i alpha) s'
  end.
\end{Coqsrc}

For instance the interval $[6,70]$ leads $\omega^2$ to $\omega\times 2 + 56$. Thus this interval is not $\omega^2$-mlarge.


\begin{Coqsrc}
Compute pp (gnaw (omega * omega) (interval 6 70)).
\end{Coqsrc}

\begin{Coqanswer}
 = (omega * 2 + 56)%pT1
     : ppT1
\end{Coqanswer}

Let us try another computation.

\begin{Coqsrc}
Compute (gnaw (omega * omega) (interval 6 700)).
\end{Coqsrc}

\begin{Coqanswer}
 = zero : T1
\end{Coqanswer}

We may say that the interval $[6,700]$ is $\omega^2$-large, since it leads to $0$, but nothing assures us that the condition of minimality is satisfied.

The following lemma relates minimal largeness with the function 
\texttt{gnaw}. 

\begin{Coqsrc}
Lemma mlarge_iff alpha x (s:list nat) :
  s <> nil -> ~ In 0 (x::s) ->
  mlarge alpha (x::s) <-> gnaw alpha (but_last x s) = one.
 \end{Coqsrc}

For instance, we can verify that the interval $[6,509]$ is $\omega^2$-mlarge.

 \noindent
\emph{From Module~\href{../src/html/hydras.Epsilon0.Large_Sets_Examples.html}{Epsilon0.Large\_Sets\_Examples}}
\begin{Coqsrc}
Example Ex1 : mlarge (omega * omega) (interval 6 510).
\end{Coqsrc}




Now, consider any natural number $k>0$. We would like to compute
a number $l$ such that the interval $[k,l]$ is $\alpha$-mlarge. So, 
the standard battle starting with $\iota(\alpha)$ and the replication factor $k$ will end after $(l-k+1)$ steps.



First, we notice that this  number $l$ exists, thanks to the following theorems:

\begin{Coqsrc}
canonS_LT:
  forall (i : nat) (alpha : T1),
  nf alpha -> alpha <> zero -> canonS alpha i < alpha.

T1_wf: well_founded LT.
\end{Coqsrc}


Moreover, it is unique:


\begin{Coqsrc}
Lemma mlarge_unicity alpha k l l' : 
  mlarge alpha (interval (S k) l) ->
  mlarge alpha (interval (S k) l') ->
  l = l'.
\end{Coqsrc}

Thus, it seems obvious that there should be a function, parameterized by $\alpha$ which associates to any  strictly positive integer $k$ the number $l$ such that
the interval $[k,l]$ is $\alpha$-large. It would be fine to write in \gallina{} a definition like this:

\begin{Coqbad}
Function L  (alpha: E0) (i:nat) :  nat := ...
\end{Coqbad}

But we do not know how to fill the dots yet \dots{}   In the next section, we will 
use \coq{} to reason  about the \emph{specification} of \texttt{L},
prove properties of any function which satisfies this specification, and finally define a correct function with the help of the \texttt{coq-equations} plug-in.

\section{Looking for a function to define}

Let $0<\alpha<\epsilon_0$ be an ordinal term. We consider the functions which associate to each stritly positive integer $k$ the number $l$, where 
the interval $[k,l-1]$\;\footnote{also denoted by $[k,l[$}  is $\alpha$-mlarge.

\begin{remark}
The upper bound of the considered interval has been chosen to be  $l-1$ and not $l$, in order to simplify some statements and proofs in composition lemmas associated to ordinals of the form $\alpha\times i$ and 
$\omega^\alpha\times i + \beta$.
In order to consider any ordinal below $\epsilon_0$, we consider a special case for $\alpha=0$.
\end{remark}


\subsection{Formal specification}

Our specification of the function \texttt{L} is as follows:

\begin{Coqsrc}
Inductive L_spec : T1 -> (nat -> nat) -> Prop :=
  L_spec0 :
    forall f, (forall k, f k = k) ->  L_spec zero f
| L_spec1 : forall alpha f,
    alpha <> zero ->
    (forall k, mlarge alpha (interval (S k) (Nat.pred (f (S k))))) ->
    L_spec alpha f.
\end{Coqsrc}


Note that, for $\alpha\not=0$, the value of $f(0)$ is not specified.
Nevertheless, the restriction of $f$ to the set of strictly positive integers is unique (up to extensionnality).

\begin{Coqsrc}
Lemma L_spec_unicity alpha f g :
  L_spec alpha f -> L_spec alpha g ->
  forall k, f (S k) = g (S k).
\end{Coqsrc}


\subsection{Properties derived from \texttt{L\_spec}}



Let us now prove properties of any function $f$ which satisfies 
\texttt{L\_spec}. We are looking for properties which could be used for writing \emph{equations} and prove the correctness of the function generated by the \texttt{coq-equations} plugin. Moreover, they will give us some examples of
$L_\alpha$ for small values of $\alpha$. 

Our exploration of the $L_\alpha$s will follow the usual scheme : transfinite induction, and proof-by-cases : zero, successors and limit ordinals.

\index{Maths!Transfinite induction}

\subsubsection{The  ordinal zero}

The base case is directly a consequence of the specification.

\begin{Coqsrc}
Lemma L_zero_inv f : L_spec zero f -> forall k, f (S k) = S k.
\end{Coqsrc}

\subsubsection{Successor ordinals}

Let $\beta$ be some ordinal, and assume the arithmetic function $f$ satisfies 
the specification $\texttt{L\_spec}\;\beta$.  Let $k$ be any natural number.
Any path from $\texttt{succ}\,\beta$ to $0$ starting at $k+1$ can be decomposed into a first step from $\texttt{succ}\,\beta$ to $\beta$, then a path from
$\beta$ at $k+2$ to $0$. 
By hypothesis the interval $[k+2, f(k+2)-1]$ is $\beta$-mlarge.

If we assume the inequality $k+1\leq f(k+2)$, we infer that the interval 
$[k+1, f(k+2)]$ is $\beta+1$-mlarge. This new hypothesis allows us 
to apply the following lemma 
(from~\href{../src/html/hydras.Prelude.MoreLists.html\#interval_app}{Prelude.MoreLists}).

\begin{Coqsrc}
Lemma interval_app (i j k:nat):
  (i <= j)%nat -> (j <= k)%nat ->
  interval i k = interval i j ++ interval (S j) k.
\end{Coqsrc}

For ensuring this property, we assume that $f\;k$ is always greater than $k$, which we note \texttt{S <= f}, or \texttt{(fun\_le S f)} (defined 
in~\href{../src/html/hydras.Prelude.Iterates.html\#fun_le}{Prelude.Iterates}).

\begin{Coqsrc}
Definition fun_le f g  := forall n:nat,  f n <=  g n.
\end{Coqsrc}

It looks also natural to show that the functions we consider are strictly monotonous. The section on successor ordinals has thus the following structure.

\begin{Coqsrc}
Section succ.
   Variables (beta : T1) (f : nat -> nat).

   Hypotheses (Hbeta : nf beta)
              (f_mono : strict_mono f)
              (f_Sle : S <<= f)
              (f_ok : L_spec beta f).

   Definition L_succ := fun k => f (S k).

   Lemma L_succ_mono : strict_mono L_succ.

   Lemma L_succ_Sle : S <<= L_succ.
  
   Lemma L_succ_ok : L_spec (succ beta) L_succ.
     
End succ.

\end{Coqsrc}

\subsubsection{Limit ordinals}

Let $\lambda<\epsilon_0$ be any limit ordinal. In a similar way as for successors, we decompose any path from $\lambda$ (at $k$) into a step to
$\canonseq{\lambda}{k}$, then to $0$. In the following section, we assume that there exists Ã  correct function for $\canonseq{\lambda}{k}$, \emph{for any strictly positive $k$}.

\begin{Coqsrc}
Section lim.
  Variables (lambda : T1)
            (Hnf : nf lambda)
            (Hlim : limitb lambda)
            (f : nat -> nat -> nat)
            (H : forall k, L_spec (canonS lambda k) (f (S k))).
  
  Let L_lim k := f k (S k).

  Lemma L_lim_ok : L_spec lambda L_lim.
  
End lim.
\end{Coqsrc}

\subsection{First results}

Applying the previous lemmas on successors and limit ordinals, 
we get several correct implementations of \texttt{(L\_spec $\alpha$)} for small values of $\alpha$.

\subsubsection{Finite ordinals}

By iterating the functional \texttt{L\_succ}, we get a realization of
\texttt{(L\_spec (fin $i$))} for any natural number $i$. 

\begin{Coqsrc}
Definition L_fin i := fun k => (i + k)%nat.

Lemma L_fin_ok i : L_spec (fin i) (L_fin i).
\end{Coqsrc}

\subsubsection{The first limit ordinal \texorpdfstring{$\omega$}{omega}}

The lemmas \texttt{L\_fin\_ok} and \texttt{L\_lim\_ok}   allow us to get 
by diagonalization a correct implementation for 
\texttt{L\_spec omega}.

\begin{Coqsrc}
Definition L_omega k := S (2 * k)%nat.

Lemma L_omega_ok : L_spec omega L_omega.
\end{Coqsrc}

\subsubsection{Towards  \texorpdfstring{$\omega^2$}{omega*omega}}

We would like to get exact formulas for the ordinal $\omega^2$, a.k.a.
$\varphi_0(2)$. This ordinal is the limit of the sequence $\omega\times i\;(i \in \mathbb{N}$. Thus, we have to study ordinals of this form, then use 
our lemma on limits.

The following lemma establishes a path from $\omega\times ( i+1)$ to
$\omega \times i$.

\begin{Coqsrc}
Lemma path_to_omega_mult (i k:nat) :
  path_to (omega * i)
                (interval (S k) (2 * (S k)))
                (omega * (S i)).
\end{Coqsrc}

Let us consider a path from  $\omega\times(i+1)$ to $0$ starting at $k+1$.
A first ``big step'' will lead to $\omega\times i$ at $2(k+1)$. If $i>0$, the
next jump leads to $\omega\times(i-1)$ at $2(2(k+1))+1$, etc.

The functional \texttt{iterate}, similar to Standard Library's \texttt{Nat.iter},
is defined and studied in~\href{../src/html/hydras.Prelude.Iterates.html\#iterate}{Prelude.Iterates})

\begin{Coqsrc}
Fixpoint iterate {A:Type}(f : A -> A) (n: nat)(x:A) :=
  match n with
  | 0 => x
  | S p => f (iterate  f p x)
  end.
\end{Coqsrc}

The following lemma expresses the length of the mlarge sequences associated with finite multiples of $\omega$.


\begin{Coqsrc}
Lemma omega_mult_mlarge_0 i  : forall k,
    mlarge  (omega * (S i))
            (interval (S k)
                      (Nat.pred (iterate (fun p =>  S (2 * p)%nat)
                                         (S i)
                                         (S k)))).
\end{Coqsrc}

Thus, we infer the following result:

\emph{From Module~ \href{../src/html/hydras.Epsilon0.Large_Sets.html\#L_omega_mult}{Epsilon0.Large\_Sets}}


\begin{Coqsrc}
Definition L_omega_mult i (x:nat) :=  iterate L_omega i x.

Lemma L_omega_mult_ok (i: nat) :  L_spec (omega * i) (L_omega_mult i).
\end{Coqsrc}

For instance, let us consider the ordinal $\omega\times 8$, and a sequence 
starting at $k=5$.

\begin{Coqsrc}
Compute L_omega_mult 8 5.
\end{Coqsrc}

\begin{Coqanswer}
= 1535
     : nat
\end{Coqanswer}

More generally, we prove the equality $L_{\omega\times i}(k)=2^i\times(k+1)-1$.

\begin{Coqsrc}
Lemma L_omega_mult_eqn (i : nat) :
  forall (k : nat),  (0 < k)%nat  ->
                     L_omega_mult i k = (exp2 i * S k - 1)%nat.
\end{Coqsrc}


By diagonalization, we obtain a simple formula for $L_{\omega^2}$.

\begin{Coqsrc}
Definition L_omega_square k := iterate (fun z => S (2 * z)%nat)
                                        k
                                        (S k).

Lemma L_omega_square_eqn k :
  (0 < k)%nat ->
  L_omega_square k = (exp2 k * (k + 2) - 1)%nat.


Lemma L_omega_square_ok: L_spec (omega * omega) 
          L_omega_square.

Compute L_omega_square 8.
\end{Coqsrc}

\begin{Coqanswer}
 = 2559
     : nat
\end{Coqanswer}


%%%% ICI 


\subsubsection{Going further}
Let us consider a last example, ``computing'' $L_{\omega^3}$.
Since the canonical sequence associated with this ordinal is composed of the
$\omega^2\times i\;(i\in\mathbb{N}_1)$, we have to study this sequence.

To this end, we prove a generic lemma, which expresses $L_{\omega^\alpha\times i}$ in terms of $L_{\omega^\alpha}$. Note that in this correction lemma, we assume that the fonction associated with $\alpha$ is stritly monotonous and 
greater or equal than the successor function. 

\begin{Coqsrc}
Section phi0_mult.
 Variables (alpha : T1) (f : nat -> nat).
 Hypotheses (Halpha : nf alpha)
            (f_mono : strict_mono f)
            (f_Sle : S <<= f)
            (f_ok : L_spec (phi0 alpha) f).

 Definition L_phi0_mult i := iterate f i.

Lemma L_phi0_mult_ok i: 
  L_spec (ocons alpha i zero)  (L_phi0_mult (S i)).

 Lemma L_phi0_mult_smono i: strict_mono (L_phi0_mult i).

 Lemma L_phi0_mult_Sle i: S <<=  L_phi0_mult (S i).

End phi0_mult.
\end{Coqsrc}

Let us look 
at the ordinal $\omega^2\times i$, using \texttt{L\_phi0\_mult}

\begin{Coqsrc}
 Definition L_omega_square_times i :=  iterate L_omega_square i.

 Lemma L_omega_square_times_ok i : 
    L_spec (ocons 2 i zero) (L_omega_square_times (S i)).
 Proof.
  apply L_phi0_mult_ok.
  -  auto with T1.
  -  apply L_omega_square_Sle.
  -  apply L_omega_square_ok.
 Qed.
\end{Coqsrc}


We are now ready to get an exact formula for $L_{\omega^3}$. 
\begin{Coqsrc}
Definition L_omega_cube  := L_lim  L_omega_square_times .

Lemma L_omega_cube_ok : L_spec (phi0 3) L_omega_cube.
\end{Coqsrc}


The function  $L_{\omega^3}$  is just obtained by diagonalization upon $L_{\omega^2\times i}$.

\begin{Coqsrc}
Lemma L_omega_cube_eqn i : L_omega_cube i = L_omega_square_times i (S i).
Proof.   reflexivity. Qed.
\end{Coqsrc}

Thus, for instance, $L_{\omega^3}(3)=L_{\omega^2\times 4}(3)$.
So, we obtain an exact expression of this number.


\begin{Coqsrc}
Lemma L_omega_cube_3_eq:
   let N := exp2 95 in
   let P := (N * 97 - 1)%nat in
    L_omega_cube 3  =  (exp2 P * (P + 2) - 1)%nat.
\end{Coqsrc}


This number is quite big. Using \texttt{Ocaml}'s \texttt{float} arithmetic,
we can [under-]approximate it by $2^{3.8\times10^{30}}\times 3.8\times{10^{30}}$.

\begin{Coqsrc}
# let exp2 x = 2.0 ** x;;

val exp2 : float -> float = <fun>
#   exp2 95.0 *. 97.0 -. 1.0;;
- : float = 3.84256588194182037e+30
# let n = exp2 95.0 ;;
# let p = n *. 97.0 -. 1.0;;
val p : float = 3.84256588194182037e+30

Estimation :
2 ** (3.84 e+30) * 3.84 e+30.
\end{Coqsrc}


\section{Using \texttt{Equations}}
\label{sect:equations}

Note that we did not define any function $L_\alpha$ \emph{for any $\alpha<\epsilon_0$} yet. We have got no more than a collection of proved realizations of $\texttt{L\_spec}\;\alpha$ for several values of $\alpha$.

\index{Coq!Plug-ins!Equations}

Using the \texttt{coq-equations} plug-in by 
M. Sozeau~\cite{sozeau:hal-01671777}, we will now define a function \texttt{L\_} which maps any ordinal  $\alpha<\epsilon_0$ to a proven realization of 
$\texttt{L\_spec}\;\alpha$.   
\subsection{Definition}

In order to get a total function, we use our type \texttt{E0} of well-formed ordinal terms,(see Sect~\vref{sect:E0-def}).  Our definition is structured along a well-founded recursion and
a case-study (zero, limit and successor ordinals). 


\vspace{4pt}XS
\noindent
\emph{From Module~\href{../src/html/hydras.Epsilon0.L_alpha.html\#L_}{L\_alpha}).}

 
\begin{Coqsrc}
From Equations Require Import Equations.
Require Import ArithRing Lia.

Instance Olt : WellFounded Lt := Lt_wf.
Hint Resolve Olt : E0.

(** Using Coq-Equations for building a function which satisfies 
    Large_sets.L_spec *)

Equations  L_ (alpha: E0) (i:nat) :  nat  by wf  alpha Lt :=
  L_ alpha  i with E0_eq_dec alpha Zero :=
    { | left _ =>  i ;
      | right nonzero
          with Utils.dec (Limitb alpha) :=
          { | left _ =>  L_ (Canon alpha i)  (S i) ;
            | right notlimit =>  L_ (Pred alpha) (S i)}}.

Solve All Obligations with auto with E0.
\end{Coqsrc}

It is worth looking at the answer from \texttt{Equations} and check (with \texttt{About} ) all the lemmas this plug-in gives you for free. We show here only a part of \coq's anwer.


\begin{Coqanswer}
L__obligations_obligation_1 is defined
L__obligations_obligation_2 is defined
L__obligations is defined
L__clause_1 is defined
L__functional is defined
L_ is defined
...
L__equation_1 is defined
L__graph_mut is defined
L__graph_rect is recursively defined
L__graph_correct is defined
L__elim has type-checked, generating 1 obligation
L__elim is defined
FunctionalElimination_L_ is defined
FunctionalInduction_L_ is defined
\end{Coqanswer}

Sometimes, these automatically generated statements may look cryptic. 

\begin{Coqsrc}
About L__equation_1.
\end{Coqsrc}

\begin{Coqanswer}
L__equation_1 :
forall (alpha : E0) (i : nat),
L_ alpha i = L__unfold_clause_1 alpha (E0_eq_dec alpha Zero) i
\end{Coqanswer}

In most cases, it may be useful to write human-readable  paraphrases of these statements.

\begin{Coqsrc}
Lemma L_zero_eqn : forall i, L_ Zero i = i.
Proof. intro i; now rewrite L__equation_1. Qed.

Lemma L_lim_eqn alpha i : Limitb alpha -> L_ alpha i =
                                        L_ (Canon alpha i) (S i).

Lemma L_succ_eqn alpha i :  L_ (Succ alpha) i = L_  alpha (S i).
\end{Coqsrc}

Using these three lemmas as rewrite rules, we can prove more properties of the \texttt{L\_} family of functions, including its correctness w.r.t. the specification
\texttt{L\_spec}.


\begin{Coqsrc}
Lemma L_ge_S alpha : alpha <> Zero -> S <<= L_ alpha.

Lemma L_omega : forall k, L_ omega%e0 k = S (2 * k)%nat.

Theorem L_correct alpha : L_spec (cnf alpha) (L_ alpha).
\end{Coqsrc}


\subsubsection{Back to Hydra battles}

Theorem \texttt{battle\_length\_std } of
Module~\href{../src/html/hydras.Hydra.Hydra_Theorems.html\#battle_length_std}{Hydra.Hydra\_Theorems} relates the length of standard battles with the functions $L\_alpha$.

\begin{Coqsrc}
Theorem battle_length_std (alpha : E0)  :
  alpha <> Zero ->
  forall k, (1 <= k)%nat ->
            battle_length standard k (iota (cnf alpha))
                         (L_ alpha (S k) - k).
\end{Coqsrc}



\section{The Wainer-Hardy hierarchy}

In order to give an idea of the complexity of the functions  $L_\alpha$s, we compare them with a better known family of functions, the so called \emph{Wainer-Hardy hierarchy} of fast growing functions,
presented for instance in~\cite{Promel2013}. 
\index{Maths!Hardy Hierarchy}

For each ordinal $\alpha$ below $\epsilon_0$, $H_\alpha$ is a 
total arithmetic function, defined  by  transfinite recursion on $\alpha$, according to three cases:

\index{Maths!Transfinite induction}

\begin{itemize}
\item If $\alpha=0$, then $\H_\alpha (k)= k$ for any natural number $k$.
\item If $\alpha=\textrm{succ}(\beta)$, then 
$H_\alpha(k)=H_\beta(k+1)$ for any $k \in \mathbb{N}$
\item If $\alpha$ is a limit ordinal, then 
$\H_\alpha(k) = H_{(\canonseq{\alpha}{k+1})}(k)$ for any $k\in \mathbb{N}$.
\end{itemize}

\subsection{Hardy functions in \texttt{Coq}}


We define a function \texttt{H\_} of type \texttt{E0 -> nat -> nat} by transfinite induction over the type \texttt{E0} of the well formed ordinals below $\epsilon_0$.

\vspace{4pt}
\emph{From Module~\href{../src/html/hydras.Epsilon0.H_alpha.html\#H_}{Epsilon0.H\_alpha}}


\index{Coq!Plug-ins!Equations}
\index{Functions!H@H\_ (Hardy hierarchy)}

\begin{Coqsrc}
Equations H_ (alpha: E0) (i:nat) :  nat  by wf  alpha lt :=
  H_ alpha  i with E0_eq_dec alpha Zero :=
    { | left _ =>  i ;
      | right nonzero
          with Utils.dec (Limitb alpha) :=
          { | left _ =>  H_ (Canon alpha (S i))  i ;
            | right notlimit =>  H_ (Pred alpha) (S i)}}. 

Solve All Obligations with auto with E0.
\end{Coqsrc} 
 


\begin{Coqsrc}
Lemma H_zero_eqn : forall i, H_ Zero i = i.
Proof.   intro i; now rewrite H__equation_1.  Qed.

Lemma H_eq2 alpha i : Is_Succ alpha ->
                      H_ alpha i = H_ (Pred alpha) (S i).

Lemma H_lim_eqn alpha i : Limitb alpha ->
                      H_ alpha i =  H_ (Canon alpha (S i)) i.

Lemma H_eq4  alpha i :  H_ (Succ alpha) i = H_ alpha (S i).
\end{Coqsrc}


\subsection{First  steps of the Hardy hierarchy}
Using rewrite rules from \texttt{H\_eq1} to \texttt{H\_eq4}, we can explore the functions $H_\alpha$ for some small values of $\alpha$.

\subsubsection{Finite ordinals} 

By induction on $i$, we prove a simple expression of \texttt{H\_ (OF i)}, where 
\texttt{OF $i$}  is the $i$-th finite ordinal.

\begin{Coqsrc}
Lemma H_Fin : forall i k: nat,  H_ i k = (i+k)%nat.
Proof with eauto with E0.
  induction i.
  - intros; simpl OF; simpl; autorewrite with H_rw E0_rw ... 
  - intros ;simpl; autorewrite with H_rw E0_rw ... 
    rewrite IHi; lia. 
Qed.
\end{Coqsrc}

\subsubsection{Multiples of \texorpdfstring{$\omega$}{omega}}

Since the canonical sequence of $\omega$ is composed of finite ordinals, 
it is easy to get the formula associated with $H_\omega$.


\begin{Coqsrc}
Lemma H_omega : forall k, H_ Omega k = S (2 * k)%nat.
Proof with auto with E0.
  intro k; rewrite H_lim_eqn ...
  - replace (Canon omega (S k)) with (Fin (S k)).
    + rewrite H_Fin; lia.
    +  now autorewrite with E0_rw.
Qed.
\end{Coqsrc}


Before going further, we prove a useful rewriting lemma:

\begin{Coqsrc}
Lemma H_Plus_Fin alpha : forall i k : nat,
    H_ (alpha + i)%e0 k = H_ alpha (i + k)%nat.
(* Proof by induction on i *)
\end{Coqsrc}


Then, we get easily formulas for $H_{\omega+i}$, and $H_{\omega\times i}$ for any natural number $i$.

\begin{Coqsrc}
Lemma H_omega_double k : H_ (omega * 2)%e0 k =  (4 * k + 3)%nat.
Proof.
 rewrite H_lim_eqn; simpl Canon.
 - ochange  (CanonS  (omega * 2)%e0 k)  (omega + (S k))%e0.
  + rewrite H_Plus_Fin, H_omega;  lia.
  -  now compute.
Qed.


Lemma H_omega_3 k : H_ (omega * 3)%e0 k = (8 * k + 7)%nat.

Lemma H_omega_4 k : H_ (omega * 4)%e0 k = (16 * k + 15)%nat.

Lemma H_omega_i i  : forall k,
    H_ (omega * i)%e0 k = (exp2 i * k + Nat.pred (exp2 i))%nat.
\end{Coqsrc}

Crossing a new limit, we prove the following equality: 
$$H_{\omega^2} (k) = 2 ^ {k+1} \times (k+1) - 1$$.

\begin{Coqsrc}

Lemma H_omega_sqr : forall k,
    H_ (Phi0  2)%e0 k = (exp2 (S k ) *  S k - 1)%nat.
Proof.
  intro k; 
   rewrite H_lim_eqn; auto with E0.
  - ochange (Canon (Phi0 2) (S k)) (omega * (S k))%e0.
    +  rewrite H_omega_i; simpl (exp2 (S k)).
       *  rewrite Nat.add_pred_r.
          -- lia. 
          --   generalize (exp2_not_zero k);  lia.
    + cbn; f_equal; lia.
Qed.
\end{Coqsrc}

\subsubsection{New limits}

Our next step would be to prove an exact formula for $H_{\omega^\omega}(k)$.
Since the canonical sequence of $\omega^\omega$ is composed of all the
$\omega^i$, we first need to express $H_{\omega^i}$ for every natural number $i$.

Let $i$ and $k$ be two natural numbers. 
The ordinal $\canonseq{\omega^(i+1)}{k}$ is the product
$\omega^i \times k$, so we need also to consider ordinals of this form.

\begin{enumerate}
\item First,  we express $H_{\omega^\alpha \times (i+2)}$ in terms of
$H_{\omega^\alpha \times (i+1)}$.

\begin{Coqsrc}
Lemma H_Omega_term_1 : alpha <> Zero -> forall  k,  
    H_ (Omega_term alpha (S i)) k =
    H_ (Omega_term alpha i) (H_ (Phi0 alpha) k).
\end{Coqsrc}

\item
Then, we prove by induction on $i$ that $H_{\omega^\alpha \times (i+1)}$ is just the
$(i+1)$-th iterate of $H_{\omega^\alpha}$.


\begin{Coqsrc}
Lemma H_Omega_term (alpha : E0)  :
alpha <> Zero -> forall i k, 
  H_ (Omega_term alpha i) k = iterate  (H_ (Phi0 alpha)) (S i) k.
\end{Coqsrc}

\item In particular, we have got a formula for $H_{\omega^{i+1}}$.

\begin{Coqsrc}
Definition H_succ_fun f k := iterate f (S k) k.

Lemma H_Phi0_succ alpha  : alpha <> Zero -> forall k,
      H_ (Phi0 (Succ alpha)) k = H_succ_fun (H_ (Phi0 alpha)) k. 

Lemma H_Phi0_Si : forall i k,
      H_ (Phi0 (S i)) k = iterate H_succ_fun i (H_ omega) k. 
\end{Coqsrc}

\end{enumerate}
We get now a  formula for $H_{\omega^3}$:

\begin{Coqsrc}
Lemma H_omega_cube : forall k,
    H_ (Phi0 3)%e0 k = iterate (H_ (Phi0 2))  (S k) k.
Proof.
  intro k; rewrite <-FinS_eq, -> Fin_Succ, H_Phi0_succ; auto.
  compute; injection 1; discriminate.
Qed.
\end{Coqsrc}


t seems hard to capture the complexity of this function by looking only at this
``exact'' formula. 
Let us consider a simple example, the number $H_{\omega^3}(3)$.  

\begin{Coqsrc}
Section H_omega_cube_3.
  
Let f k :=   (exp2 (S k ) * (S k) - 1)%nat.

Remark R0 k :  H_ (Phi0 3)%e0 k = iterate f (S k) k.
\end{Coqsrc}

Thus, the number $H_{\omega^3}(3)$ can be written as four nested applications of $f$.

\begin{Coqsrc}
Fact F0 : H_ (Phi0 3) 3 = f (f (f (f 3))).
 rewrite R0; reflexivity. 
Qed.
\end{Coqsrc}

In order to make this statement more readable, we can introduce a local dÃ©finition.

\begin{Coqsrc}
Let N := (exp2 64 * 64 - 1)%nat.
\end{Coqsrc}

This number looks quite big; let us compute an approximation in \texttt{Ocaml}:


\begin{Coqsrc}
# (2.0 ** 64.0 *. 64.0 -. 1.0);; 
\end{Coqsrc}

\begin{Coqanswer}
- : float = 1.1805916207174113e+21
\end{Coqanswer}


\begin{Coqsrc}
Fact F1 : H_ (Phi0 3) 3 = f (f N).
Proof.
 rewrite H_omega_cube_0; reflexivity. 
Qed.


Lemma F1_simpl : H_ (Phi0 3) 3 =
                 (exp2 (exp2 (S N) * S N) * (exp2 (S N) * S N) - 1)%nat.

\end{Coqsrc}


In a more classical writing, this number is displayed as follows:

{\Large
$$
H_{\omega^3}(3) =  2 ^ {(2 ^ {N + 1} \times (N+1) } )  \times  (2 ^ {N+1} \times ( N +1) ) - 1
$$
}


We leave as an exercise to determine the best approximation as possible of
 the size of this number (for instance its number of digits).  For instance, if
we do not take into account the multiplications in the formula above,
we obtain that, in base $2$, the number $H_{\omega^3}(3)$ has at least
$2^{10^{21}}$  digits. But it is still an under-approximation !


\begin{Coqsrc}
End H_omega_cube_3.
\end{Coqsrc}




Now, we have got at last an exact formula for $H_{\omega^\omega}$.

\begin{Coqsrc}
Lemma H_Phi0_omega : forall k, H_ (Phi0 omega) k =
                               iterate H_succ_fun  k (H_ omega) k.
Proof with auto with E0.
  intro k; rewrite H_lim_eqn,  <- H_Phi0_Si ...
  -  rewrite CanonS_Canon, CanonS_Phi0_lim;  f_equal ...
Qed.
\end{Coqsrc}

Using extensionality of the functional \texttt{iterate}, we can get a closed formula.

\begin{Coqsrc}
Lemma H_Phi0_omega_closed_formula k :
  H_ (Phi0 omega) k =
  iterate (fun (f: nat -> nat) (l : nat) => iterate  f (S l) l)
               k
               (fun k : nat => S (2 * k)%nat)
               k.
\end{Coqsrc}




Note that this short formula contains two occurences of the functional \texttt{iterate}, the outer one is in fact a second-order iteration (on type \texttt{nat -> nat)}
and the inner one  first-order (on type \texttt{nat}). 


\subsection{Abstract properties of H-functions}
~\label{sect:H-alpha-prop} 

Since pure computation seems to be useless for dealing with expressions of the form $H_\alpha(k)$, even for small values of $\alpha$ and $k$, we need to prove theorems for comparing $H_\alpha(k)$ and $H_\beta(l)$, in terms of comparison
between $\alpha$ and $\beta$ on the one hand, $k$ and $l$ on the other hand.

But beware of non-theorems! For instance, one could believe that $H$ is monotonous in its first argument. The following proof shows this is false.

\begin{Coqsrc}
Remark H_non_mono1 :
  ~ (forall alpha beta k, (alpha <= beta)%e0 ->
                          (H_ alpha k <= H_ beta k)%nat).
Proof.
 intros H ;specialize (H 42 omega 3).
 assert (H0 :(42 <= omega)%e0) by (repeat split; auto).  
 apply H in H0; rewrite H_Fin, H_omega  in H0; lia.
Qed.
\end{Coqsrc}

On the contrary, the fonctions of the Hardy hierarchy have the following five properties. %%% ICI lien avec KS81

For any $\alpha < \epsilon_0$,
\begin{itemize}
\item the function $H_\alpha$ is strictly monotonous :
      For all $n,p \in\mathbb{N}, n < p \Rightarrow H_\alpha(n)< H_\alpha(p)$.
\item If $\alpha \not= 0$, then for every $n$, $n<H_\alpha(n)$.
\item The function $H_\alpha$ is pointwise less or equal than $H_{\alpha+1}$

\item For any $n\geq 1$, $H_\alpha(n)<H_{\alpha+1}(n)$.
\emph{We say that $H_{\alpha+1}$ dominates $H_\alpha$ from $1$}.
\item For any $n$ and $\beta$, if $\alpha \xrightarrow[n]{} \beta$, then
$H_\beta(n)\leq H_\alpha(n)$.
\end{itemize}

\index{Maths!Transfinite induction}

In \coq{}, we follow the  proof in~\cite{KS81}. This proof is mainly a single  proof by transfinite induction on $\alpha$ of the conjonction of the five properties.
For each $\alpha$, the three cases : $\alpha=0$, $\alpha$ is a limit, and 
$\alpha$ is a successor are considered. Inside each case, the five sub-properties are proved sequentially. 

\begin{Coqsrc}
Section Proof_of_Abstract_Properties.
  Record P (alpha:E0) : Prop :=
    mkP {
        PA : strict_mono (H_ alpha);
        PB : alpha <> Zero -> forall n,  (n < H_ alpha n)%nat;
        PC : H_ alpha <<= H_ (Succ alpha);
        PD : dominates_from 1 (H_ (Succ alpha)) (H_ alpha);
        PE : forall beta n, Canon_plus n alpha beta -> 
                            (H_ beta n <= H_ alpha n)%nat}.


Theorem P_alpha : forall alpha, P alpha.
  Proof.
    intro alpha; apply well_founded_induction with lt.
   (* rest of proof skipped *)

Section Proof_of_Abstract_Properties.
\end{Coqsrc}


\subsection{Comparison between \texttt{L\_} and \texttt{H\_} }

By well-founded induction on $\alpha$, we prove that our $L$ hierachy is ``almost'' the Hardy hierarchy (up to a small shift).

\emph{From Module~\href{../src/html/hydras.Epsilon0.L_alpha.html\#H_L_}{Epsilon0.L\_alpha}}

\begin{Coqsrc}
 Theorem H_L_ alpha: forall i:nat,  (H_ alpha i <= L_ alpha (S i))%nat.
\end{Coqsrc}
 
\subsubsection{Back to hydras}

The following theorem relates the length of (standard) battles with the Hardy hierarchy.

\emph{From Module~\href{../src/html/hydras.Epsilon0.L_alpha.html}{Epsilon0.L\_alpha}}

\begin{Coqsrc}
Theorem battle_length_std_Hardy (alpha : E0) :
  alpha <> Zero ->
  forall k , 1 <= k -> exists l: nat,  
       H_ alpha k - k <= l /\
       battle_length standard k (iota (cnf alpha)) l.    
\end{Coqsrc}

\section{The Wainer hierarchy (functions \texorpdfstring{$F_\alpha$}{F\_alpha})}


\index{Maths!Wainer Hierarchy}

The Wainer hierarchy~\cite{BW85, Wainer1970, KS81}, is also a family of fast growing functions, indexed by ordinals below $\epsilon_0$, by the following equations:

\label{F_equations}
\begin{itemize}
\item $F_0(i)=i+1$
\item $F_{\beta+1}(i)= (F_\beta)^{(i+1)}(i)$, where $f^{(i)}$ is the $i$-th iterate of $f$.
\item $F_\alpha(i) = F_{\canonseq{\alpha}{i}} (i)$ if $\alpha$ is a limit ordinal.
\end{itemize}

A first attempt is to write a definition of $F_\alpha$ by equations, in the same as for $H\_alpha$.  We use the functional \texttt{iterate} defined in 
Module~\href{../src/html/hydras.Prelude.Iterates.html\#iterate}{Prelude.Iterates}.

\begin{Coqsrc}
Fixpoint iterate {A:Type}(f : A -> A) (n: nat)(x:A) :=
  match n with
  | 0 => x
  | S p => f (iterate  f p x)
  end.
\end{Coqsrc}

The following code comes from 
 \url{../src/html/hydras.Epsilon0.F_alpha.html}.


\index{Coq!Plug-ins!Equations}
\begin{Coqsrc}
Fail Equations F_ (alpha: E0) (i:nat) :  nat  by wf  alpha Lt :=
  F_ alpha  i with E0_eq_dec alpha Zero :=
    { | left _ =>  i ;
      | right nonzero
          with Utils.dec (Limitb alpha) :=
          { | left _ =>  F_ (Canon alpha i)  i ;
            | right notlimit =>  iterate (F_ (Pred alpha))  (S i) i}}.
\end{Coqsrc}

\begin{Coqanswer}
The command has indeed failed with message:
In environment
alpha : E0
notlimit : Limitb alpha = false
nonzero : alpha <> Zero
i : nat
F_ : forall x : E0, nat -> x < alpha -> nat
The term "F_ (Pred alpha) ?x" has type "Pred alpha < alpha -> nat"
while it is expected to have type "Pred alpha < alpha -> Pred alpha < alpha"
(cannot unify "nat" and "Pred alpha < alpha").
\end{Coqanswer}


We presume that this error comes from the recursive call of \texttt{F\_} inside
an application of \texttt{iterate}. The workaround we propose is to define first 
the iteration of \texttt{F\_}  as an helper $F^*$, then to define the function $F$ as a ``iterating $F^*$ once''.

\texttt{Equations} accepts the following definition, relying on  lexicographic ordering on pairs $(\alpha,n)$.


\label{sect:F-equations}

\index{Coq!Plug-ins!Equations}
\index{Functions!F\_@F\_ (Wainer hierarchy)}
\index{Maths! Fast growing functions}
  
\begin{Coqsrc}
Definition call_lt (c c' : E0 * nat) :=
  lexico Lt (Peano.lt) c c'.

Lemma call_lt_wf : well_founded call_lt.
  unfold call_lt; apply Inverse_Image.wf_inverse_image,  wf_lexico.
  -  apply E0.Lt_wf.
  -  unfold Peano.lt; apply Nat.lt_wf_0. 
Qed.

Instance WF : WellFounded call_lt := call_lt_wf.

Equations  F_star (c: E0 * nat) (i:nat) :  nat by wf  c call_lt :=
    F_star (alpha, 0) i := i;
    F_star (alpha, 1) i
      with E0_eq_dec alpha Zero :=
           { | left _ => S i ;
             | right nonzero
                 with Utils.dec (Limitb alpha) :=
                 { | left _ => F_star (Canon alpha i,1) i ;
                   | right notlimit =>
                     F_star (Pred alpha, S i)  i}};
    F_star (alpha,(S (S n))) i :=
               F_star (alpha, 1) (F_star (alpha, (S n)) i).

(* Finally, F_ alpha is defined as its first iterate ! *)

Definition F_  alpha i := F_star (alpha, 1) i.
\end{Coqsrc}

It is quite easy to prove that our function \texttt{F\_} satisfies the equations on page~\pageref{sect:F-equations}.

\begin{Coqsrc}
Lemma F_zero_eqn : forall i, F_ Zero i = S i.

Lemma F_lim_eqn : forall alpha i,  Limitb alpha ->
                               F_ alpha i = F_ (Canon alpha i) i.

Lemma F_succ_eqn : forall alpha i,
    F_ (Succ alpha) i = iterate (F_ alpha) (S i) i.
\end{Coqsrc}

As for the Hardy functions, we can use these equalities as rewrite rules for
``computing'' some values of $F_\alpha(i)$, for small values of $\alpha$.

\begin{Coqsrc}
Lemma LF1 : forall n,  F_ 1 n = S (2 * n).

Lemma LF2 : forall i, (exp2 i * i < F_ 2 i)%nat.
\end{Coqsrc}


Like in Sect~\ref{sect:H-alpha-prop}, we prove by induction the following properties (see~\cite{KS81}). 

\begin{Coqsrc}
Theorem F_alpha_mono alpha : strict_mono (F_ alpha).
 
Theorem F_alpha_ge_S alpha : forall n, (n < F_ alpha n)%nat.

Theorem F_alpha_Succ_le alpha : F_ alpha <<= F_ (Succ alpha).

Theorem F_alpha_dom alpha : dominates_from 1 (F_ (Succ alpha)) (F_ alpha).

Theorem F_alpha_beta alpha : forall beta n, Canon_plus n alpha beta -> 
                                        (F_ beta n <= F_ alpha n)%nat.
\end{Coqsrc}

As a corollary, we prove the following proposition, p. 284 of~\cite{KS81}.

\begin{quote}
  If $\beta<\alpha$, $F_\alpha$ dominates $F_\beta$.

($f$ is said to \emph{dominate} $g$ if $f(p)>g(p)$ for any all sufficiently large $p$).
\end{quote}

\begin{Coqsrc}
Lemma Propp284 : forall alpha beta : E0, 
   beta < alpha -> dominates (F_ alpha) (F_ beta).
\end{Coqsrc}

\index{Exercises}

\begin{exercise}
Let us quote a theorem from ~\cite{KS81} (page 297).

\begin{quote}
\begin{align*}
  H_{\omega^\alpha}(n+1) &\geq F_{\alpha}(n) \quad (n\geq 1, \alpha<\epsilon_0) \\
 F_{\alpha}(n+1) &\geq H_{\omega^\alpha}(n) \quad (n\geq 1, \alpha<\epsilon_0) 
\end{align*}
Thus $H_{\omega^\alpha}$ and $F_{\alpha}$ have essentially the same order of growth.

\end{quote}

 But, before trying to prove these facts, look at the definition of function $H$ in Ketonen and Solovay's paper ! Is it really the same as the definition we quote from Pr{\H o}mel's chapter~\cite{Promel2013},
whereas \cite{KS81} define $H_\alpha(n)$ as ``the least integer $k$ such that $[n,k]$ is $\alpha$-large''. Thus, it may be useful to adapt the statement above.



\end{exercise}

\index{Exercises}

\begin{exercise}
Prove the following result~\cite{KS81}(p. 298).

\begin{quote}
   For $n\geq 2$ and $\alpha \geq 3$, $F_\alpha(n+1)\geq 2^{F_\alpha(n)}$.
\end{quote}
\end{exercise}



%  \subsection{Gnawing ordinals}

% \begin{definition}[After~\cite{KS81}]
%   Let $S$ be a finite set of positive integers, and $\alpha$ be an ordinal strictly less than $\epsilon_0$.  Let us denote by $s=s_1,s_2, \dots, s_N$ the sequence of 
% the elements of $S$, enumerated in strictly increasing order.

% We consider the sequence of ordinals $\alpha_o=\alpha, \alpha_1=\canonseq{\alpha_0}{s_1},\dots,\alpha_{i+1}=\canonseq{\alpha_i}{s_{i+1}},\dots, 
% \alpha_{N}=\canonseq{\alpha_{N-1}}{s_N}$.
% We denote by $\gnaw{s}{\alpha}$ the last ordinal of the sequence, \emph{i.e.}  $\alpha_N$.
% \end{definition}


% The following function computes $\gnaw{s}{\alpha}$ by recursion on $s$.
% \vspace{4pt}



% For instance, let us consider the ordinal $\omega^\omega$, and try some sequence of integers. 


% \begin{Coqsrc}
% Compute pp (gnaw (omega ^ omega) (1::nil)).  
% \end{Coqsrc}


% \begin{Coqanswer}
%   = omega%pT1 : ppT1
% \end{Coqanswer}


% \begin{Coqsrc}
% Compute pp (gnaw (omega ^ omega) (1::2::nil)).  
% \end{Coqsrc}

% \begin{Coqanswer}
% = P_fin 2
%      : ppT1
% \end{Coqanswer}

% Likewise, we can verify that $\gnaw{\omega^\omega}{\langle 1,2,3 \rangle}=1$
% and $\gnaw{\omega^\omega}{\langle 1,2,3,4 \rangle}=0$.

% \begin{Coqsrc}
% Example omega_omega_1_4 : gnaw (omega ^omega) (interval 1 4) = 0.
% Proof. trivial. Qed.

% Example omega_omega_1_3 : gnaw (omega ^omega) (interval 1 3) = 1.
% Proof. trivial. Qed.
% \end{Coqsrc}

% \begin{remark}
% \label{remark:gnaw-vs-battles}
% Let us consider an hydra battle, where Hercules always chops off the rightmost head of the hydra. Let $\alpha<\epsilon_0$ be an ordinal number, and 
% $s=\langle i_1<i_2<\dots<i_N\rangle$ be  any finite sequence of positive integers.
% Then the battle initiated by the hydra $\iota(\alpha)$, with $s$ as the sequence of successive replication factors, leads to the hydra $\iota(\gnaw{s}{\alpha})$ as the final state.
% \end{remark}


% \subsection{Large sequences}

% \begin{remark}
% In their article~\cite{KS81}, Ketonen and Solovay use the appellation ``large set'' instead of ``large sequence'', but their definitions use an enumeration of the elements in increasing order. Thus, we shall use the term ``sequence'' when referring to our implementation in \coq{}, and ``set'' when referring to the statements of~\cite{KS81}.
% \end{remark}


% \begin{definition}[After\cite{KS81}]
% The sequence $s$ is said to be \emph{$\alpha$-large} if $\gnaw{\alpha}{s}=0$.  
% \end{definition}


% \begin{Coqsrc}
% Definition largeb (alpha : T1) (s: list nat) :=
%   match gnaw alpha s with
%     | zero => true
%     | _ => false
%   end.


% Definition large (alpha : T1) (s : list nat) : Prop :=
%   largeb alpha s.
% \end{Coqsrc}




% For instance, the sequence $\langle 1,2,3,4 \rangle$ is $\omega^\omega$-large but not
% $\omega^{\omega+1}$-large, since $\gnaw{\omega^{\omega+1}}{\langle 1,2,3,4\rangle}$ is equal to $\omega \times 2 + 4$.


% %\omega^\omega+\omega^2\times 3 + \omega\times 4+ 5$.


% \begin{Coqsrc}
% Compute largeb (omega^omega) (interval 1 4).  
% \end{Coqsrc}

% \begin{Coqanswer}
% = true : bool
% \end{Coqanswer}

% \begin{Coqsrc}
% Compute largeb (omega^(omega+1)) (interval 1 4).
% \end{Coqsrc}

% \begin{Coqanswer}
% = false : bool
% \end{Coqanswer}


% \begin{remark}
% A sequence $s$ is $\alpha$-large if (still considering Hercules ``righmost-head'', tactic), it leads to Hercules' victory.
% \end{remark}


% \subsection{A little game}  

% Let $\alpha<\epsilon_0$ be an ordinal, and $i$ a positive integer. We want to guess the least natural number  $j$  such that the interval $[i,i+j]$ is $\alpha$-large.
% Equivalently, we should have $\gnaw{\alpha}{[i, i+j-1]}=1$.

% The following functions takes three arguments: an ordinal $\alpha$, and two positive natural numbers  $i$ and $j$ (we assume, but not verify that $i$ and $j$ are strictly positive). It returns one of the three possible answers:

% \begin{itemize}
% \item \texttt{Ok} if $j$ is the smallest integer such that the interval $[i,i+j]$ is $\alpha$-large
% \item \texttt{Too\_far} if $[i,i+j]$ is  $\alpha$-large, but $j$ is not the smallest such positive integer
% \item \texttt{(Remaining $\beta$)} if $j$ is too small, and gnawing $\alpha$ with
%   $[i,i+j]$ is still equal to $\beta$, instead of $0$
% \end{itemize}


% \vspace{4pt}
% \noindent
% \emph{From Module~\href{../src/html/hydras.Epsilon0.Large_Sets_Demo.html}{Ordinals.Epsilon0.Large\_Sets\_Demo}}   

% \begin{Coqsrc}
% Inductive answer : Set := You_won | Too_far | Remaining (rest : ppT1).

% Definition large_set_check alpha i j :=
%   let beta := gnaw alpha (interval i (Nat.pred j))
%   in match beta with
%      | one => Ok
%      | zero => Too_far
%      |  _ => Remaining (pp (canonseq j beta))
%      end.
% \end{Coqsrc}

% \subsubsection{\texorpdfstring{$\omega$}{omega}-large intervals}


% For instance, let us consider the ordinal $\omega$ and start with $i=1$.

% \begin{Coqsrc}
% Compute large_set_check omega 1 2.
% \end{Coqsrc}

% \begin{Coqanswer}
%      = Ok
%      : answer
% \end{Coqanswer}

% Let us give greater values of $i$, still with the ordinal $\omega$.

% \begin{Coqsrc}
% Compute large_set_check omega 2 3.
% \end{Coqsrc}


% \begin{Coqanswer}
%   = Remaining 1
%      : answer
% \end{Coqanswer}

% \begin{Coqsrc}
% Compute large_set_check omega 3 3.
% \end{Coqsrc}

% \begin{Coqanswer}
%   = Remaining 3
%      : answer
% \end{Coqanswer}

% \begin{Coqsrc}
% Compute large_set_check omega 2 4.
% \end{Coqsrc}


% \begin{Coqanswer}
%   = Ok
%      : answer
% \end{Coqanswer}

% \begin{Coqsrc}
% Compute large_set_check omega 3 6.
% \end{Coqsrc}

% \begin{Coqanswer}
%   = Ok
%      : answer
% \end{Coqanswer}

% It looks like every request to compute (\texttt{large\_set\_check omega $i$ $2\times i$})  will succeed. Let us try an example. 

% \begin{Coqsrc}
% Compute large_set_check omega 49 98.
% \end{Coqsrc}

% \begin{Coqanswer}
%   = Ok
%      : answer
% \end{Coqanswer}

% \subsubsection{\texorpdfstring{$\omega^2$}{omega\^{}2}-large intervals}

% Still using \texttt{Compute} and \texttt{large\_set\_check}, we obtained the 
% following values of $j$, the least integer such that the interval $[i,j]$ is $\omega^2$ large.

% $$
% \begin{array}{|c|c|}
% \hline
%   i & j \\
% \hline 
% 1 & 4 \\
% 2 & 14 \\
% 3 & 38 \\
% 4 & 94 \\
% 5 & 222 \\
% % 6 & 510 
% \hline
% \end{array}
% $$

% \begin{exercise}
% Please give the 6-th and 7-th line of the array above.
% \end{exercise}


% \subsubsection{The limits of (pure) computation}

% Let us now play with bigger ordinals, for instance $\alpha=\omega^\omega$ or
% $\alpha=\omega^{\omega + 1}$. We notice that, even for small values of $i$, it is hard
% to guess values of $j$ such that $[i,i+j]$ is $\alpha$-large.

% \begin{Coqsrc}
% Compute large_set_check (omega ^ omega) 1 4.
% \end{Coqsrc}

% \begin{Coqanswer}
%  = Ok
%      : answer
% \end{Coqanswer}

% \begin{Coqsrc}
% Compute large_set_check (omega ^ omega) 2 38.
% \end{Coqsrc}

% \begin{Coqanswer}
%  = Ok
%      : answer
% \end{Coqanswer}




% \begin{Coqsrc}
% Compute large_set_check (omega ^ omega) 3 1000.
% \end{Coqsrc}

% \begin{Coqanswer}
%   = Remaining (omega ^ 2 * 2 + omega * 220 + 798)%pT1
%      : answer
% \end{Coqanswer}


% \begin{Coqsrc}
% Compute large_set_check (omega ^ omega) 3 1798.
% \end{Coqsrc}

% \begin{Coqanswer}
%   = Remaining (omega ^ 2 * 2 + omega * 220)%pT1
%      : answer
% \end{Coqanswer}


% \begin{Coqsrc}
% Compute large_set_check (omega ^ omega) 3 5000.
% \end{Coqsrc}

% \begin{Coqanswer}
%   = Remaining (omega ^ 2 * 2 + omega * 218 + 2198)%pT1
%      : answer
% \end{Coqanswer}







% \begin{Coqsrc}
% Compute large_set_check (omega ^ (omega + 1)) 3 5000.
% \end{Coqsrc}

% \begin{Coqanswer}
%  = Remaining
%          (omega ^ omega * 2 + omega ^ 3 * 4 + 
%           omega ^ 2 * 4 + omega * 1148 +  4222)%pT1
%      : answer  
% \end{Coqanswer}

% \begin{Coqsrc}
% Compute large_set_check (omega ^ (omega + 1)) 3 10000.
% \end{Coqsrc}


% \begin{Coqanswer}
% Warning: To avoid stack overflow, large numbers in nat are interpreted as
% applications of Init.Nat.of_uint. [abstract-large-number,numbers]

%     = Remaining
%          (omega ^ omega * 2 + omega ^ 3 * 4 + 
%           omega ^ 2 * 4 + omega * 1147 +
%           8446)%pT1
%      : answer
% \end{Coqanswer}

% Since computation is not enough, let us comme back to proofs, or, better, proofs \emph{and} computations.

% \subsection{Proving largeness}



% %%% ICI %%%

% \subsection{$n$-large and $\omega$-large intervals }

% A finite ordinal is just made out of \texttt{zero} and \texttt{succ} constructions.
% Thus any sequence of strictly positive integers of length greater than  or equal to $n$ will completely gnaw the ordinal $n$.

% Concerning the first limit ordinal $\omega$ the largeness of a sequence $s$ depends only on its first element and the length of the rest of the sequence (please keep in mind that the argument $i$ of $\canonseq{\alpha}{i}$ is meaningful only if $\alpha$ is a limit ordinal).
% The following proposition is labeled $4.2$ in~\cite{KS81}.

% \begin{proposition}
%   For $n<\omega$, a set $X$id $n$-large if and only if $|X|\geq n$.
% A finite set $X$ is $\omega$-large if $|X|>\min{X}$.
% \end{proposition}

% Rewritten in terms of list of strictly positive integers, we get the following statements:

% \begin{Coqsrc}
% Lemma large_n_iff : forall s (n:nat) , ~ In 0 s  ->
%                                   large n s  <-> (n <= List.length s)%nat.
% \end{Coqsrc}


% \begin{Coqsrc}
% Lemma large_omega_iff : forall s n,  ~In 0 (n::s) -> 
%                                             large omega (n::s) <->
%                                             (n <=  List.length s)%nat.
% \end{Coqsrc}



% % \begin{Coqsrc}
% % (* sorted list of natural numbers greater than or equal to n *)

% % Inductive sorted_ge (n: nat) : list nat -> Prop :=
% % | sorted_ge_nil : sorted_ge n nil
% % | sorted_ge_one : forall p, n<=p ->
% %                             sorted_ge n (p::nil)
% % | sorted_ge_cons: forall p q s,  n<=p -> p<q ->
% %                                  sorted_ge p (q::s) ->
% %                                  sorted_ge n (p::q::s).
% % \end{Coqsrc}



% \subsection{Mimimal large sequences}



% Let us consider \emph{minimal} large sequences, \emph{i.e.} large sequences 
% the strict prefix of which do not lead to $0$. In other words, only the last ordinal 
% defined by the sequence is null.  For this purpose, we use the predicate \texttt{path\_to} introduced page~\pageref{path-to-definition}.

% \begin{Coqsrc}
% Definition mlarge alpha s := path_to zero s alpha.
% \end{Coqsrc}






