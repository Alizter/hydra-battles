% easychair.tex,v 3.5 2017/03/15

\documentclass{easychair}
%\documentclass[EPiC]{easychair}
%\documentclass[EPiCempty]{easychair}
%\documentclass[debug]{easychair}
%\documentclass[verbose]{easychair}
%\documentclass[notimes]{easychair}
%\documentclass[withtimes]{easychair}
%\documentclass[a4paper]{easychair}
%\documentclass[letterpaper]{easychair}

\usepackage{doc}
\usepackage{tikz}
\usepackage{tikzsymbols}
\usepackage{pifont}
\newtheorem{theorem}{Theorem}
\usetikzlibrary{arrows}

%\usepackage[firstpageonly=false, color={[gray]{0.5}},
%   scale=2.0, text=DRAFT]{draftwatermark}
% -------------------------------
%%%% For Alectryon

\usepackage{texments}
%%% for movies by alectryon
\usepackage{./assets/alectryon}
\usepackage{./assets/pygments}
%%% One hypothesis per line 
\makeatletter
\renewcommand{\alectryon@hyps@sep}{\alectryon@nl}
\makeatother

%%% \snippets{A,B,C,…} inputs a series of snippets as one block (with \itemsep
%%% between them).  A, B, C should be paths to files in snippets/.
\usepackage{etoolbox}
\makeatletter
\newcommand{\inputsnippets}[1]
  {{\setlength{\itemsep}{1pt}\setlength{\parsep}{0pt}% Adjust spacing
    \alectryon@copymacros\begin{io}
      \forcsvlist{\item\@inputsnippet}{#1}
    \end{io}}}
\let\input@old\input % Save definition of \input
\newcommand{\@inputsnippet}[1]
  {{\renewenvironment{alectryon}{}{}% Skip \begin{alectryon} included in snippet
    \input@old{snippets/#1}}}
\makeatother

%---------------------------- 
\newcommand{\canonseq}[2]{\mbox{$\{#1\}(#2)$}}

\usepackage{varioref}
\newtheorem{todo}{To do}
\usepackage{amsfonts, afterpage}
\usepackage{xspace}

\newcommand{\easychair}{\textsf{easychair}}
\newcommand{\miktex}{MiK{\TeX}}
\newcommand{\texniccenter}{{\TeX}nicCenter}
\newcommand{\makefile}{\texttt{Makefile}}
\newcommand{\latexeditor}{LEd}

%\makeindex

%% Front Matter
%%
% Regular title as in the article class.
%
\title{Hydras,  Ordinals \& Co.   \\
  A library in Coq of entertaining formal mathematics}



\author{
Pierre Castéran \inst{1}
\and
    Jérémy Damour \inst{2}
\and
Karl Palmskog \inst{3}
\and Clément Pit-Claudel \inst{4}
\and Théo Zimmermann \inst{5}
}


\institute{
Univ. Bordeaux, CNRS, Bordeaux INP, LaBRI, UMR 5800, F-33400 Talence, France  %\\
 % \email{pierre.casteran@labri.fr}
\and
Univ. de Paris, F-75013 Paris, France
\and
KTH Royal Institute of Technology, Stockholm, Sweden
\and
MIT CSAIL, Cambridge, Massachusetts, USA
\and
Inria, Univ. de Paris, CNRS, IRIF, UMR 8243, F-75013 Paris, France
}



\authorrunning{Castéran, Damour, Palmskog, Pit-Claudel and Zimmermann}

\titlerunning{\Hydras}

\newcommand{\TODO}[2][]{[\textcolor{red}{TODO (#1):} \emph{#2}]}
\newcommand{\coq}{Coq\xspace}
\newcommand{\community}{Coq-community\xspace}
\newcommand{\gaia}{Gaia\xspace}
\newcommand{\alectr}{Alectryon\xspace}
\newcommand{\equations}{Equations\xspace}
\newcommand{\Hydras}{Hydras \& Co$\text.$\xspace}
%\newcommand{\Hydras}{Hydra-battles\xspace}

\begin{document}

\maketitle


\begin{abstract}
  \Hydras is a collaborative library of discrete mathematics for the
  \coq proof assistant, developed as part of the \community organization
  on GitHub. The Coq code is accompanied
  by an electronic book, generated with the help of the \alectr
  literate proving tool. We present the evolution of the mathematical
  contents of the library since former presentations at JFLA meetings.
  Then, we describe how the structure of the project is determined
  by two requirements which must be continuously satisfied.
  First, the Coq code needs to be compatible with its ever-evolving
  dependencies (the Coq proof assistant and several Coq packages both from
  inside and outside \community) and reverse dependencies (\community
  projects that depend on it). Second, the book needs to be consistent
  with the Coq code, which undergoes frequent changes to improve
  structure and include new material. We believe \Hydras demonstrates
  that books on formalized mathematics are not limited to
  providing exposition of theories and reasoning techniques---they
  can also provide inspiration and entertainment that transcends educational goals.
\end{abstract}


% \setcounter{tocdepth}{2}
% {\small
% \tableofcontents}


%------------------------------------------------------------------------------
\section{Introduction}
\label{sect:introduction}

\subsection{Background}

Libraries of formalized mathematics based on proof assistants, such as \coq, Lean, and Isabelle/HOL, are continually growing in size and scope.
For example, the core projects in the Mathematical Components family for Coq amount to more than 160,000 lines of code and 11,000 lemmas~\cite{Nie2020a}, while Lean's Mathlib consists of more than 140,000 lines of code and 34,000 declarations~\cite{Mathlib}. However, after a key mathematical definition or result is added to a library, it needs be \emph{documented}~\cite{alectryonpaper} and \emph{maintained}~\cite{vanDoorn2020}.

Maintenance includes not only adaptation to changes in new proof assistant versions, but also reorganization to ease future maintenance effort and accommodate new contributions. Documentation is usually two-fold: \emph{source code comments} that describe specific definitions and results in-line and \emph{books} that carefully introduce the library and its idioms~\cite{MCB}. The former tends to be terse and dense and serves experienced users, while the latter is more long-winded and exhaustive and serves beginners. As a library changes and expands, all its documentation needs to be made consistent and complete. Authors use a wide range of techniques, including literate programming~\cite{Knuth1984} and custom tools, to pretty-print and check source code snippets and generate proof assistant output.

While books that document proof assistant libraries are valuable to beginners, the purpose of recently published books is mainly instrumental, i.e., to teach a certain topic or technique. We believe that books can instead become \emph{ends in themselves}---not just sources of learning, but also sources of inspiration and entertainment.

\subsection{Vision}
The \Hydras project, part of \community on GitHub~\cite{CoqCommunity}, aims to be an experimental platform for the collaborative development of documented libraries of formal proofs. \community is a community organization that we founded in 2018 with two goals in mind: providing a solution for the long-term maintenance of interesting \coq packages, and working collaboratively on documentation projects. The \Hydras project demonstrates that these two goals are not independent: interesting \coq packages can become the basis for new documentation.
%
This umbrella project now includes evolved versions of the former Cantor and Additions libraries~\cite{CantorContrib,AdditionsContrib} (under the new names of Hydra-battles and Addition-chains), the Ackermann sub-library extracted from Russel O'Connor's Goedel library~\cite{OConnor05, Goedel}, and a bridge to the \gaia library by José Grimm~\cite{Gaia,grimm:hal-00911710}.
%
By following this approach of commenting interesting \coq packages, we provide new documentation content that contributes to the diversity of the thriving \coq ecosystem.

We call on the \coq users in the JFLA community and beyond to come and join us in this effort, by bringing new interesting projects which are worth presenting to \coq learners, \emph{a.k.a.} \coq users, and guiding them in their exploration.
%
We also always have project ideas to extend further our explorations and anyone is welcome to join the team by sending small or larger contributions through pull requests.
%
The current state of the project is already the result of such evolutions after several of us contributed project solutions and new proposals to the initial version of the first author.

Futhermore, contrary to traditionally published books, the ``book'' that forms part of this project is intended to be forever evolving. As new \coq formalization patterns and proof techniques appear, the book can be adapted to demonstrate their use (in case they fit well with our applications).
%
By using modern maintenance techniques such as continuous integration and deployment, we can ensure that this documentation stays up to date with the latest \coq releases. With \alectr~\cite{alectryonpaper, alectryongithub}, we ensure that code and documentation are always in sync.

\subsection{Hydra games}

We chose to build our library and book on two simple themes which allow many variations: computing powers in a monoid, and Kirby and Paris' hydra battles. In the interest of space, we shall present only the second one in this article.


Hydra games (also known as \emph{Hydra battles}) appear in an article published in 1982 by two mathematicians, 
Laurie Kirby and Jeff Paris: \emph{Accessible Independence Results for Peano Arithmetic}~\cite{KP82}.
This article describes a game between two players: Hercules and a hydra.
A short description of the game  can be found in~\cite{bauer2008, KP82, JFLA2018paper}. One can also play with
Andrej Bauer's simulator~\cite{BauerHydra}.
In a few words:
\begin{itemize}
\item A hydra is a finite tree, traditionally presented with the root at the bottom, the leaves of which are called \emph{heads}
  (Fig~\ref{fig:round}).
\item At every round, Hercules chops off one head of the hydra. If the head is at a distance greater than 1 from the root,
  then some sub-tree $h$ of the hydra is copied a certain amount $n$ of times. The number $n$ of copies and the sub-tree $h$ may depend of the considered variant of the game
  or the time elapsed since the beginning of the fight.
  Figure~\ref{fig:round} shows an example with $n=2$.
\end{itemize}



\begin{figure}[h]
  \centering
  \begin{tikzpicture}[very thick, scale=0.3]
  \node (h1) at (4,0){$\bullet$};
  \node[blue] (h2) at (4,2){$\bullet$};
  \node[blue] (h3) at (2,4){$\bullet$};
  \node[blue] (h4) at (0,6){$\bullet$};
  \node[blue] (h5) at (4,6){$\bullet$};
  \node[red!90!black] (h6) at (6,4){$\bullet$};
  \draw (h1) -- (h2) ;
  \draw (h2) -- (h3) ;
  \draw (h2) -- node[red!90!black,font=\small,sloped,shift={(0.01,-0.075)},rotate=90]{\textbf{\ding{34}}} (h6);
  \draw (h3) -- (h4) ;
  \draw (h3) -- (h5) ;
 
\node (hn1) at (14,0){$\bullet$};
\node[blue] (hn2) at (12,2) {$\bullet$};
\node[blue] (hn3) at (12,4) {$\bullet$};
\node[blue] (hn4) at (10,6){$\bullet$};
  \node[blue] (hn5) at (12,6){$\bullet$};
  \draw (hn1) -- (hn2) ;
  \draw (hn2) -- (hn3) ;
  \draw (hn3) -- (hn4) ;
  \draw (hn3) -- (hn5) ;
\node (hn2b) at (14,2) {$\bullet$};
\node (hn3b) at (14,4) {$\bullet$};
\node (hn4b) at (13.4,6){$\bullet$};
  \node (hn5b) at (14.6,6){$\bullet$};
  \draw (hn1) -- (hn2b) ;
  \draw (hn2b) -- (hn3b) ;
  \draw (hn3b) -- (hn4b) ;
  \draw (hn3b) -- (hn5b) ;
  \node (hn2c) at (16,2) {$\bullet$};
\node (hn3c) at (16,4) {$\bullet$};
\node (hn4c) at (16,6){$\bullet$};
  \node (hn5c) at (18,6){$\bullet$};
  \draw (hn1) -- (hn2c) ;
  \draw (hn2c) -- (hn3c) ;
  \draw (hn3c) -- (hn4c) ;
  \draw (hn3c) -- (hn5c) ;
\end{tikzpicture}

  \caption{Two successive states of a hydra in a battle.  Hercules chopped off the rightmost head of the hydra (red), and the whole left tree except the root node (blue) was copied twice.}
  \label{fig:round}
\end{figure}



 %  \begin{figure}[htb]
% \centering
% \begin{tikzpicture}[very thick, scale=0.3]
% \node (foot) at (10,0) {$\bullet$};
% \node (N1) at (2,2) {$\bullet$};
% \node (N2) at (10,2) {$\bullet$};
% \node (N22) at (7,2) {$\bullet$};
% \node (N3) at (14,2) {$\bullet$};
% \node (N4) at (18,2) {$\Smiley[2][green]$};
% \node (N5) at (0,4) {$\bullet$};
% \node (N6) at (2,5) {$\Smiley[2][green]$};
% \node (N7) at (4,6) {$\Smiley[2][green]$};
% \node (N88) at (7,4) {$\bullet$};
% \node (N8) at (10,4) {$\bullet$};
% \node (N9) at (14,6) {$\Smiley[2][green]$};
% \node (N10) at (0,8) {$\Smiley[2][green]$};
% \node (N11) at (10,7) {$\Smiley[2][green]$};
% \node (N111) at (7,7) {$\Smiley[2][green]$};
% \draw (foot) to [bend left=10] (N1);
% \draw (foot) -- (N2);
% \draw (foot) -- (N22);
% \draw (foot) -- (N3);
% \draw (foot) -- (N4);
% \draw (N1) to  (N5);
% \draw (N1) to   [bend left=10] (N6);
% \draw (N1) to   [bend right=20] (N7);
% \draw (N2) to  (N8);
% \draw (N22) to  (N88);
% \draw (N8) to  (N11);
% \draw (N88) to  (N111);
% \draw (N3) to  (N9);
% \draw (N5) to  (N10);
% \end{tikzpicture}
% \caption{The hydra associated with the ordinal $\omega^{\omega+2}+\omega^\omega \times 2 + \omega + 1$ \label{fig:iota-example}}

% \end{figure}

Kirby and Paris prove the following theorems, applying
combinatorial results about ordinal numbers by Jussi Ketonen and Robert Solovay~\cite{KS81}.

\begin{theorem}
  In the Hydra game, Hercules eventually wins, whichever the strategy of both players :
  choice of a head to chop off, choice of the number of copies. 
 \label{kp:thm1}
\end{theorem}

\begin{theorem}
  Theorem~\ref{kp:thm1} cannot be proved in Peano Arithmetic. \label{kp:thm2}
\end{theorem}

The contrast between the simplicity of the statements above and the complexity of their proofs convinced us that it is a good theme for a commented library~\cite{HydraBattles} of formal proofs written for the \coq proof assistant~\cite{Coq}. 

Complex formalisations and proofs are explained in an
  electronic book~\cite{HydraBook} (PDF document of over 280 pages). Whenever various reasonable choices exist, we try to present and compare the alternatives.
  For instance, Figures~\ref{fig:Ex42E0} and \ref{fig:Ex42-schutte} show two radically different proofs of the equality
  $\omega+42+\omega^2=\omega^2$. The first one is a simple proof by computation, the second one shows how this equality
  is a consequence of the axioms of the set-theoretic model  by Kurt Schütte~\cite{schutte}. 

This work is also an opportunity to 
 provide concrete examples of formalization and proof techniques: operational type classes, functions defined by  equations, dependently typed functions, etc. It may be also used as a library on ordinal numbers, for instance for proving termination properties.

 Prior stages of this project have already been presented at
 JFLA~\cite{PCiota, JFLA2018paper}.
We present recent evolutions of the library: new results, interaction within the \community project~\cite{CoqCommunity}, and documentation generated with \alectr~\cite{alectryonpaper, alectryongithub}.

\section{Recent developments}
The 2018 article~\cite{JFLA2018paper} presented a formal proof of  a variant of Theorem~\ref{kp:thm2}:

\begin{theorem}
  Let $\mu$ be any ordinal strictly less than $\epsilon_0$.
  There is no function mapping hydras to the segment $[0,\mu)$ that could be used as a measure for  proving the termination of  \emph{any} hydra battle.\label{thm3}
\end{theorem}

Our proof was based on the construction of a battle, where the
number of copies at each round is given by the elimination of an existential quantifier. So, it was mandatory to consider the class of \emph{all} hydra battles.

Unfortunately, the examples  most commonly shown in the litterature
(see for instance~\cite{KP82, bauer2008, BauerHydra}) 
assume that the hydra grows $n$ copies at step $n$ of the game, which is incompatible with our proof.
We prove now that Theorem~\ref{thm3} still holds with these typical battles.
%by borrowing new combinatorial results from~\cite{KS81}.
Since we are looking  for a minoration of the length of such battles,
we can work with the following hypotheses and invariants, 
without any loss of generality.
 
 \begin{itemize}
   \item The game starts at an initial step $i\in\mathbb{N}$ (not necessarily $0$).
   \item  The hydra is always the  representation as a tree of some ordinal strictly below $\epsilon_0$ in Cantor normal
     form (thus, the rightmost branch is also one of the shortest).
     For instance, Fig~\ref{fig:round} shows the hydras respectively associated with  $\omega^{\omega^2+1}$ and $\omega^{\omega^2}\times 3$. 
 
 \item Hercules always chops off the rightmost head of the hydra.
 \end{itemize}
 
 In mathematical terms, if at step $n\geq i$, the hydra is associated with the ordinal $\alpha$, at step $n+1$ it is associated with
 $\canonseq{\alpha}{n+1}$, \emph{i.e.} the $(n+1)$th element of the canonical sequence of $\alpha$~\cite{KS81}.

 Our new proof of Theorem~\ref{thm3} is based on a systematic study of strictly decreasing sequences of ordinals below $\epsilon_0$, borrowed from Ketonen and Solovay~\cite{KS81}, and the formalization of which is described  in chapters 5 and 6 of~\cite{HydraBook}.
 
We also study the number of steps of a battle:
Let $\alpha<\epsilon_0$ be an ordinal. 
We prove that  the number of steps of the battle starting with
$\alpha$ at step $i$ is greater or equal than
$H'_\alpha(i)-i$, where $H'$ is a slight variant of the Hardy hierarchy of rapidly growing functions~\cite{BW85, KS81, Promel2013, Wainer1970}.  The function $H'_\alpha$ is defined by transfinite recursion over $\alpha$ on Figures~\ref{fig:hardy-math}
and~\ref{fig:Hprime}.


\begin{figure}[h]
\begin{align}
  H'_0(i) & = i\\
  H'_\alpha(i) &= H'_{(\canonseq{\alpha}{i+1})}(i)  \quad\textit{if $\alpha$ is a limit ordinal}\\
  H'_{\alpha}(i) &=H'_\beta(i+1) \quad\textit{if $\alpha=\beta+1$}
\end{align}  
  \caption{The $H'$ rapidly growing hierarchy of arithmetical functions}
  \label{fig:hardy-math}
\end{figure}


\begin{figure}[h]
  \centering
  \fbox{
    \begin{minipage}[h]{1.0\linewidth}
 \inputsnippets{Hprime/HprimeDef}     
    \end{minipage}}
 \caption{$H'$ definition with the \texttt{coq-equations}
 plug-in~\cite{sozeau:hal-01671777}}
\label{fig:Hprime}
\end{figure}


Using $H'$s equations as rewrite rules, we can study a concrete example. We take the hydra of figure~\ref{fig:start} and $i=0$ as initial configuration. 
By a sequence of rewritings and inductions, we prove that the number of steps of the considered battle is greater or equal than $2^{2^N}$, where $N=2^{70}-1$.
More generally, we prove that, for $\alpha\geq\omega^\omega$, 
the function computing the length of the battle starting with the configuration $(\alpha,i)$ is not primitive recursive.

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[very thick, scale=0.3]
  \node (h1) at (4,0){$\bullet$};
  \node (h2) at (2,2){$\bullet$};
  \node (h3) at (0,4){$\bullet$};
  \node (h4) at (1,4){$\bullet$};
  \node (h5) at (2,4){$\bullet$};
  \node (h6) at (4.5,2){$\bullet$};
  \node (h7) at (6.5,2){$\bullet$};
  \node (h8) at (8.5,2){$\bullet$};
    \draw (h1) -- (h2) ;
    \draw (h2) -- (h3) ;
    \draw (h2) -- (h4) ;
    \draw (h2) -- (h5) ;
    \draw (h1) -- (h6) ;
    \draw (h1) -- (h7) ;
    \draw (h1) -- (h8);
 \end{tikzpicture}

  \caption{The hydra associated with the ordinal $\omega^3+3$}
  \label{fig:start}
\end{figure}




\label{sect:not-pr}

%\TODO[Clément]{Could we use a font with ligatures?}


\section{Integration with \community}

\subsection{Background}

\community is an informal organization run by volunteer Coq users on GitHub that aims to maintain interesting Coq projects for the long term and facilitate collaboration among Coq users on documentation, tooling, etc. \community was created in 2018, inspired by the {Elm Community} organization~\cite{zimmermann:tel-02451322}.
%
Such ``Community Package Maintenance Organizations'' exist in many software ecosystems, as they avoid the common problem of an important package becoming unmaintained after its author has moved on to other projects or has disappeared~\cite{zimmermann2021grounded}.

In the case of \coq, this problem is likely even more prevalent than in other ecosystems, as many packages are created by graduate students or researchers for a specific paper and not planned to be maintained for the long term by authors.
%
However, authors are generally open to having someone else who expresses interest in their work take over package maintenance.
%

\community makes it easy to change maintainers by defining a process for transferring or forking an unmaintained package, tooling for setting up good maintenance practices (such as continuous integration), and by making it possible for someone to take over a package without making a long-term commitment (as maintainers who drop out can easily be replaced by some other volunteers).

As of 2021, \community hosts over 50 projects maintained by over 30 volunteers.
%
The hosted projects come from a variety of origins.
%
Some had been maintained in the past by the \coq development team on behalf of the authors, but this meant that only minimal changes required to make the project build with new \coq versions were performed.
%
Some were still maintained by their original authors, but were transferred to enable other users to help out with maintenance and facilitate adoption of best practices on, e.g., continuous integration.
%
Others were simply unmaintained and were revived after their transfer to \community.

Given the objectives of \community, we believe it makes sense to propose a transfer anytime we encounter an interesting Coq project that is insufficiently maintained.
%
After a transfer, the \community maintainers are explicitly allowed to perform large changes and refactorings.
%
This means, for instance, that we can consolidate libraries by merging them, or split them up into several packages.

\subsection{Integration of primitive recursive functions}

In order to prove formally that the length of the
kind of hydra battles we consider is not given by a primitive recursive function, we chose to use a formalization of the primitive recursive functions that was originally part of Russell O'Connor's statement and proof of G\"{o}del's first incompleteness theorem~\cite{OConnor05, Goedel}.
For this purpose, and above all in consideration of the scientific interest of this contribution, we decided to host and maintain O'Connor's work in \community.

Since computability is a key topic in computer science teaching and O'Connor's library is a nice illustration of dependently typed programming, we decided to devote a full chapter (chapter 9 of~\cite{HydraBook}) to the formalization of primitive recursive functions, with comments on the definitions and proofs and [counter-]examples and exercises. As part of the writing process, we made the formalization into a new sub-library of the Hydra-battles library, dubbed Ackermann.

\subsection{Bridge to ordinals in Gaia}

The Gaia project by Jos\'e Grimm aimed to formalize mathematics in the style of by N. Bourbaki in Coq. The formalization of the first book by Bourbaki, on the theory of sets, was initially described in a technical report in July 2009~\cite{Grimm2009a}. Grimm then wrote (and continually updated) technical reports describing the formalization of Bourbaki's two subsequent books~\cite{Grimm2009b,Grimm2016} and additional topics in number theory~\cite{grimm:hal-00911710,Grimm2014}, before he passed away in 2019.

In 2020, members of \community transferred the Gaia source code to GitHub and adapted it for recent releases of the Mathematical Components library, which Gaia heavily relies on. Anonymous volunteers (``collaborators of Nicolas Bourbaki'') then finished the only in-progress proof left by Grimm. At around 165,000 lines of code, Gaia is currently one of the largest maintained open source Coq projects~\cite{Gaia}.

\subsection{\Hydras Genealogy and Dependencies}


\begin{figure}[h]
\centering
{\footnotesize
\begin{tikzpicture}[thick]

\begin{scope}[xshift=-6cm]
\node[rectangle, dotted,draw=black,minimum height=0.5cm,minimum width=1.5cm] (goedel) { Goedel };    
\node[rectangle, dotted,draw=black,minimum height=0.5cm,minimum width=1.5cm,right of=goedel, node distance=2cm] (additions) { Additions };
\node[rectangle, dotted,draw=black,minimum height=0.5cm,minimum width=1.5cm,right of=additions, node distance=2cm] (cantor) { Cantor };
\end{scope}

\begin{scope}[yshift=-0.7cm,xshift=0.25cm]
\node[rectangle, draw=black,dashed,minimum height=0.5cm,minimum width=1.5cm] (equations) { Equations };
\node[rectangle, draw=black,dashed,minimum height=0.5cm,minimum width=1.5cm,right of=equations, node distance=2cm] (mathcomp) { MathComp };
\node[rectangle, draw=black,minimum height=0.5cm,minimum width=1.5cm,node distance=2cm,right of=mathcomp, node distance=2cm] (paramcoq) { Paramcoq };
\end{scope}

\begin{scope}[yshift=-1.8cm,xshift=-4cm]
\node[rectangle, draw=black,minimum height=0.5cm,minimum width=1.5cm] (hydras) { Hydra-battles };
\node[rectangle, draw=black,minimum height=0.5cm,minimum width=1.5cm,right of=hydras, node distance=2.5cm] (chains) { Addition-chains };
\node[rectangle, draw=black,minimum height=0.5cm,minimum width=1.5cm,right of=chains, node distance=2.2cm] (gaia) { Gaia };
\end{scope}

\begin{scope}[yshift=-2.8cm,xshift=-6cm]
 \node[rectangle, draw=black,minimum height=0.5cm,minimum width=1.5cm] (goedelcc) { Goedel };
 \node[rectangle, draw=black,minimum height=0.5cm,minimum width=1.5cm,right of=goedelcc, node distance=2.2cm] (gaiahydras) { Gaia-hydras };
\end{scope}

\draw[->,dotted] (additions.south) -- (chains.north west) ;
\draw[->] (goedel) -- (goedelcc) ;
\draw[->] (goedel) -- (hydras.north west) ;
\draw[->] (cantor) -- (hydras.north) ;
\draw[->] (cantor.south) -- (gaia.north west) ;
\draw[->] (hydras) -- (gaiahydras) ;
\draw[->] (gaia.south west) -- (gaiahydras) ;
\end{tikzpicture}
}
\caption{Genealogy and dependencies for \Hydras packages.}
  \label{fig:round}
\end{figure}

In mainstream software, it is common for packages to continually depend on a large number of packages. In contrast, projects in the Coq ecosystem are often subject to ``dependency aversion'', where maintainers eschew depending on useful packages because it may lead to work in adapting to upstream changes. With \Hydras, we hope to demonstrate that projects with complex dependencies are feasible to manage using recent advances in build management and infrastructure.

% We could already talk a bit of the monorepo structure here, and
% defer some explanations on the tooling to the next section.

\section{Modernizing the building infrastructure}

\subsection{Documentation with \alectr}

The \Hydras book is written in LaTeX, but it makes very frequent references (about once per page, 274 snippets over 281 pages) to parts of the \coq development, showing definitions (Fig.~\ref{fig:Hprime}), computation results (Fig.~\ref{fig:Pow-evalPow17LetIn}), lemmas (Fig.~\ref{fig:Ex42E0}) and parts of  proof scripts (Fig.~\ref{fig:Ex42-schutte}). The order in which these references appear in the book is independent of the structure of our libraries, so we chose to maintain the book as a standalone document, separate from the \coq source code.  This in contrast with the Coqdoc approach, where explanatory prose is embedded within \coq source files (a detailed discussion of various approaches to the documentation of \coq developments is in \cite{alectryonpaper}).

Originally, we copied snippets from \coq sources into LaTeX manually, and recorded and inserted the corresponding outputs manually as well.  This approach is common, but brittle: changes to \coq definitions or lemmas had to be reflected in the book's sources, and we found multiple instances where the book and the \coq development had diverged.
 
We solved this maintenance issue by moving to \alectr, a tool that automatically records \coq proofs.  Instead of copy-pasting fragments into LaTeX, we now embed small LaTeX files automatically generated by \alectr from our \coq development.  Our build system guarantees that these LaTeX snippets are always up-to-date and consistent with the code (and, by comparing these snippets across releases of \coq or versions of \Hydras, we can easily spot unexpected changes).

Importing snippets into a LaTeX document was not one of the original use cases of \alectr, so we had to extend it: the original \alectr did not have support for exporting to LaTeX, and it was geared towards documenting individual source files (a style where code and prose are interleaved within the same file and code is documented in the same order as it is compiled).  We extended \alectr to support our needs by implementing a LaTeX backend, and by programming it to generate individual snippet files, one per \texttt{snippet} comment block.  The later part was straightforward: all it took was to build a custom \alectr \textit{driver}, a small (about 100 lines) Python program that leverages most of the \alectr toolchain but defines a custom frontend that understands our snippet annotations (and otherwise exposes the exact same command line as \alectr).

Once the infrastructure was in place, the transition happened gradually, over a few weeks: for each snippet of \coq code that was in the book, we had to take the following steps:

\begin{enumerate}
\item Mark the snippet in the \coq sources (we use special comments \texttt{(* begin snippet \textit{name} *)} … \texttt{(* end snippet \textit{name} *)})
\item Configure output display, using special \alectr annotations to configure what should be shown (only the inputs, inputs and outputs, some steps of the proof but not all, some proof states at key moments in a proof, etc.)
\item Replace the copy-pasted inputs and output in LaTeX with an \texttt{input} command.
\end{enumerate}

   \begin{figure}[h]
     \centering
     \fbox{
       \begin{minipage}[h]{1.0\linewidth}
         \inputsnippets{Pow/evalPow17LetIn}
       \end{minipage}}
  \caption{\label{fig:Pow-evalPow17LetIn}Automatically capturing the output of computations}
\end{figure}


  \begin{figure}[h]
    \centering
    \fbox{
      \begin{minipage}[h]{1.0\linewidth}
        \inputsnippets{E0/Ex42}
      \end{minipage}}
    \caption{A simple proof by computation}
    \label{fig:Ex42E0}
  \end{figure}



%\afterpage{\clearpage}

 


\begin{figure}[th]
  \centering
  
  

\fbox{\begin{minipage}[h]{1.0\linewidth}
  Let us prove again the equality $\omega+42+\omega^2= \omega^2$. Let us recall that $\omega^2$ is an abbreviation of $\phi_0(2)$,
\emph{i.e} the third  additive principal ordinal.

\inputsnippets{Schutte/Ex42a}


Our proof is very different from the computational proof of
Figure~\ref{fig:Ex42E0}.
By definition of additive principal ordinals, 
it suffices to prove the inequality $\omega+42< \phi_0(2)$.

\inputsnippets{Schutte/Ex42b}

Since the set \textit{AP} of additive principals  is closed under addition
(by Lemma \textit{AP\_plus\_closed}), it suffices to prove the inequalities $\omega<\omega^2$ and $42<\omega^2$.

\inputsnippets{%Schutte/Ex42d,
  Schutte/Ex42c, Schutte/Ex42e}

\end{minipage}
}
\caption{A proof interleaved with text (from the book)}
  \label{fig:Ex42-schutte}
\end{figure}


\subsection{Technologies supporting the monorepo structure}

Monorepos (shorthand for monolithic repositories) are single repositories containing multiple independent or related packages.
%
They have gained increasing popularity following experiences in large companies such as Google, but are also used at a lesser scale for managing open source projects.
%
They are known to simplify the management of dependencies, making cross-packages changes and refactorings~\cite{brito2018monorepos}.

In the context of Coq projects, they did not use to be well-supported.
%
One of the few early monorepos in the Coq ecosystem was the Mathematical Components (math-comp) repository, which used a custom build infrastructure to check multiple packages on each commit.
%
However, recent improvements in tooling have made their use easier, and therefore we have used them more and more, for instance within \community.

In the context of \Hydras, we rely on the following tools.

\paragraph{The Dune build system~\cite{dune}.}
Dune was originally designed to build OCaml projects, but was recently extended to support Coq. Dune allows building packages contained in a single source tree separately, which is essential to be able to publish the different libraries contained in a single repository as separate (opam) packages to the Coq package index.

In practice, we do still support building the whole project with coq\_makefile, and we actually rely on this build system in our documentation generation pipeline.

\paragraph{The Docker-Coq-Action~\cite{martindorel2020dockercoq}.}
This GitHub Action provides a very simple way of setting up Continuous Integration (CI) for a Coq project with an opam file.
%
At the current time, we rely on it, together with the mathcomp Docker images~\cite{mathcompdocker}, to test our two main libraries, Hydra-battles and Addition-chains, with multiple versions of Coq.

\paragraph{The Coq Nix Toolbox~\cite{cohen:hal-03366644}.}
This toolbox, based on the Nix package manager, provides an alternative way of setting up CI for a Coq project (also relying on GitHub Actions).
%
We use this Nix-based CI for several things.

\begin{enumerate}
\item To test the build of the project (as a single unit) with coq\_makefile (whereas the Docker-based CI relies on the opam packages, which use Dune to build the libraries contained in the project).

\item To generate the documentation of the project (book in PDF format and coqdoc HTML pages) by relying on the output of the coq\_makefile build.

\item To test the bridge to the Gaia library, because the Nix-based CI supports out-of-the-box caching of build dependencies.
%
Given that Gaia takes more than 5 minutes to build, this build is only done once, then reused at each new run of the CI.

\item To test compatibility with the Goedel library, which was made to depend on the Hydra-battles library since the Ackermann sub-library was moved from the former to the latter.
%
For this, we rely on the fact that the Coq Nix Toolbox has native support for generating a CI configuration that includes reverse dependency compatibility testing.
\end{enumerate}

The artifacts of the Nix builds are stored in the \community binary cache on Cachix~\cite{cachix}.
%
This means that a given version never has to be built twice and Continuous Integration can be almost instantaneous when no change has been made (e.g., after merging a pull request).

By relying on two different technologies for CI, we are able to fit a larger range of use cases, while also providing more assurance that the project does build correctly in a variety of configurations.
%
Given that the two technologies are well maintained (within \community), relying on both does not incur a significant cost, compared to the benefits they provide.

\section{Comparison of \Hydras with other Coq books}

\section{Conclusion and perspectives}


\Hydras wants to be a bridge between scientific litterature (\emph{e.g.}~\cite{KP82, KS81, schutte} and proof assistant technology. For the mathematician, it may give a concrete view of the mathematical content, not only through full proofs, but also through significative computations: examples, functions associated with constructive proofs, etc. For the \coq learner, it provides a consistent set of examples,
allowing to present and compare various formalization and proving techniques. %It may be also used as a library, through opam packages.
It is also a medium sized library (more than 50K LOC), dependent on various tools and libraries of the \coq ecosystem, which  may be also used to experiment new techniques of continuous maintenance of the code and its documentation.





%\TODO{General Conclusion}



%\subsection{Perspectives}

%\subsection{Further extensions}

We plan to extend our libraries in two main directions.

The \gaia project~\cite{Gaia}, also maintained on \community, contains a development by José Grimm~\cite{grimm:hal-00911710},  dedicated  to the implementation in \coq (SSReflect) of books from  Bourbaki's Elements of Mathematics. The set theory underpinning \gaia is derived from an earlier development by Carlos Simpson~\cite{Simpson2004,CatsZFCContrib}. \gaia contains data structures which are compatible with our ordinal notations.
Our plan is to build a  bridge between  the combinatorial results of \Hydras and the set-theoretic content of \gaia, and make possible the transfer of theorems between both libraries.
We aim also to write in \coq a formal proof of the original statement of Theorem~\ref{kp:thm2}, using O'Connor's formalization of Peano Arithmetic~\cite{Goedel}.

 \Hydras is not limited to the study of ordinal numbers and applications.
 For instance, we are also developing 
a module about efficient exponentiation algorithms, and hope
to extend our project to new topics.

\section{Acknowledgments}
\label{sect:acks}
We are grateful to the original authors and current maintainers of the Coq packages we use and depend on: José Grimm (Gaia), Russell O'Connor (Goedel), Matthieu Sozeau (Equations), the Mathematical Components team, Marc Lasson and Chantal Keller (Paramcoq), and the authors and maintainers of \coq and its associated tools.


\label{sect:bib}
\bibliographystyle{plain}
%\bibliographystyle{alpha}
%\bibliographystyle{unsrt}
%\bibliographystyle{abbrv}
\bibliography{../thebib}


\end{document}

